
import React, { createContext, useContext, useReducer, ReactNode } from 'react';
import { UserRegistration, UserUpdate, userRegistrationSchema, userUpdateSchema } from '@/schemas/validation';

export type UserRole = 'client' | 'provider' | 'admin';

export interface User {
  id: number;
  name: string;
  email: string;
  phone: string;
  role: UserRole;
  rating?: number;
  status: 'active' | 'inactive' | 'pending';
  available?: boolean;
  bankMobileNumber?: string;
  paymentMethod?: 'bank_transfer' | 'mobile_money';
  totalEarnings?: number;
  jobsCompleted?: number;
  responseRate?: number;
  joinDate: string;
  lastActive: string;
  createdAt: string;
  updatedAt: string;
}

interface UserState {
  users: User[];
  currentUser: User | null;
  isLoading: boolean;
  error: string | null;
}

type UserAction = 
  | { type: 'SET_LOADING'; payload: boolean }
  | { type: 'SET_ERROR'; payload: string | null }
  | { type: 'SET_CURRENT_USER'; payload: User | null }
  | { type: 'ADD_USER'; payload: User }
  | { type: 'UPDATE_USER'; payload: { id: number; updates: Partial<User> } }
  | { type: 'DELETE_USER'; payload: number }
  | { type: 'SET_USERS'; payload: User[] };

const initialState: UserState = {
  users: [],
  currentUser: null,
  isLoading: false,
  error: null
};

function userReducer(state: UserState, action: UserAction): UserState {
  switch (action.type) {
    case 'SET_LOADING':
      return { ...state, isLoading: action.payload };
    case 'SET_ERROR':
      return { ...state, error: action.payload, isLoading: false };
    case 'SET_CURRENT_USER':
      return { ...state, currentUser: action.payload };
    case 'ADD_USER':
      return { ...state, users: [...state.users, action.payload] };
    case 'UPDATE_USER':
      return {
        ...state,
        users: state.users.map(user =>
          user.id === action.payload.id ? { ...user, ...action.payload.updates, updatedAt: new Date().toISOString() } : user
        ),
        currentUser: state.currentUser?.id === action.payload.id 
          ? { ...state.currentUser, ...action.payload.updates, updatedAt: new Date().toISOString() }
          : state.currentUser
      };
    case 'DELETE_USER':
      return {
        ...state,
        users: state.users.filter(user => user.id !== action.payload),
        currentUser: state.currentUser?.id === action.payload ? null : state.currentUser
      };
    case 'SET_USERS':
      return { ...state, users: action.payload };
    default:
      return state;
  }
}

interface UserContextType extends UserState {
  registerUser: (userData: UserRegistration) => Promise<User>;
  loginUser: (email: string, password: string, role: UserRole) => Promise<User>;
  logoutUser: () => void;
  updateUser: (id: number, updates: UserUpdate) => Promise<void>;
  deleteUser: (id: number) => Promise<void>;
  getUserById: (id: number) => User | undefined;
  getUsersByRole: (role: UserRole) => User[];
}

const UserContext = createContext<UserContextType | undefined>(undefined);

export const UserProvider = ({ children }: { children: ReactNode }) => {
  const [state, dispatch] = useReducer(userReducer, initialState);

  const registerUser = async (userData: UserRegistration): Promise<User> => {
    dispatch({ type: 'SET_LOADING', payload: true });
    dispatch({ type: 'SET_ERROR', payload: null });

    try {
      // Validate input data
      const validatedData = userRegistrationSchema.parse(userData);
      
      // Check if email already exists
      const existingUser = state.users.find(user => user.email === validatedData.email);
      if (existingUser) {
        throw new Error('Email already registered');
      }

      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 1000));

      const newUser: User = {
        id: Date.now(), // In production, this would be generated by the backend
        name: validatedData.name,
        email: validatedData.email,
        phone: validatedData.phone,
        role: validatedData.role,
        status: validatedData.role === 'provider' ? 'pending' : 'active',
        joinDate: new Date().toISOString().split('T')[0],
        lastActive: new Date().toISOString(),
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };

      dispatch({ type: 'ADD_USER', payload: newUser });
      dispatch({ type: 'SET_LOADING', payload: false });
      
      return newUser;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Registration failed';
      dispatch({ type: 'SET_ERROR', payload: errorMessage });
      throw error;
    }
  };

  const loginUser = async (email: string, password: string, role: UserRole): Promise<User> => {
    dispatch({ type: 'SET_LOADING', payload: true });
    dispatch({ type: 'SET_ERROR', payload: null });

    try {
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 1000));

      const user = state.users.find(u => u.email === email && u.role === role);
      if (!user) {
        throw new Error('Invalid credentials or role mismatch');
      }

      if (user.status === 'inactive') {
        throw new Error('Account is deactivated');
      }

      // Update last active
      dispatch({ 
        type: 'UPDATE_USER', 
        payload: { 
          id: user.id, 
          updates: { lastActive: new Date().toISOString() }
        }
      });

      dispatch({ type: 'SET_CURRENT_USER', payload: user });
      dispatch({ type: 'SET_LOADING', payload: false });
      
      return user;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Login failed';
      dispatch({ type: 'SET_ERROR', payload: errorMessage });
      throw error;
    }
  };

  const logoutUser = () => {
    dispatch({ type: 'SET_CURRENT_USER', payload: null });
    dispatch({ type: 'SET_ERROR', payload: null });
  };

  const updateUser = async (id: number, updates: UserUpdate): Promise<void> => {
    dispatch({ type: 'SET_LOADING', payload: true });
    dispatch({ type: 'SET_ERROR', payload: null });

    try {
      // Validate update data
      const validatedUpdates = userUpdateSchema.parse(updates);
      
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 500));

      dispatch({ type: 'UPDATE_USER', payload: { id, updates: validatedUpdates } });
      dispatch({ type: 'SET_LOADING', payload: false });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Update failed';
      dispatch({ type: 'SET_ERROR', payload: errorMessage });
      throw error;
    }
  };

  const deleteUser = async (id: number): Promise<void> => {
    dispatch({ type: 'SET_LOADING', payload: true });
    dispatch({ type: 'SET_ERROR', payload: null });

    try {
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 500));

      dispatch({ type: 'DELETE_USER', payload: id });
      dispatch({ type: 'SET_LOADING', payload: false });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Delete failed';
      dispatch({ type: 'SET_ERROR', payload: errorMessage });
      throw error;
    }
  };

  const getUserById = (id: number): User | undefined => {
    return state.users.find(user => user.id === id);
  };

  const getUsersByRole = (role: UserRole): User[] => {
    return state.users.filter(user => user.role === role);
  };

  const value: UserContextType = {
    ...state,
    registerUser,
    loginUser,
    logoutUser,
    updateUser,
    deleteUser,
    getUserById,
    getUsersByRole
  };

  return (
    <UserContext.Provider value={value}>
      {children}
    </UserContext.Provider>
  );
};

export const useUsers = () => {
  const context = useContext(UserContext);
  if (context === undefined) {
    throw new Error('useUsers must be used within a UserProvider');
  }
  return context;
};
